# -*- coding: utf-8 -*-
"""MNIST - DS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fHJ34vbVw4YKKQtH75MF6NFXo6_yIWRs

# Sequential Neural Network - TensorFlow - MNIST data set

Note: due to randomness, the values of the results may change within a small amount of tolerance, and consequently, the discussion of the results

![tensorflow-machine-learning.png](data:image/png;base64,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AAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABRCAAAAACIQgAAAABAFAIAAAAAohAAAAAAEIUAAAAAgCgEAAAAAEQhAAAAACAKAQAAAABR+AYAAAAABGx6B+JSnbT+AAAAAElFTkSuQmCC)
"""

import tensorflow as tf
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import sklearn
import torch

from tensorflow.keras.datasets import mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

"""## Exploring the data:"""

# show example of image
x_train[55]

# number of images
print(f'train images:{len(x_train)} and their class is also {len(y_train)} ')

print(f'test images:{len(x_test)} and their class is also {len(y_test)}')

# data distrebution
class_distribution = pd.Series(y_train).value_counts().sort_index()
# Plotting a basic histogram
plt.hist(pd.Series(y_train), bins=10, color='skyblue', edgecolor='black')

"""## The data is generally balance but with slitly high appearance for class 1 and low appearance for class 5

## Analysis of the data content: lets try to understand information form the raw data
"""

# Threshold for white pixels
white_value = 200 / 255
image_w = 28
image_h = 28

# Lists to collect results
results = []
white_pixel_stats = {}

for i in range(10):
    # Select images of the current class
    ls_images = x_train[y_train == i]

    # Initialize list to store white pixel counts
    white_pixels_counts = []

    # Initialize a mask with True values (assume all pixels are non-white initially)
    common_non_white_mask = np.ones((image_w, image_h), dtype=bool)

    # Process each image in the current class
    for image in ls_images:
        # Count the number of white pixels in the image
        white_pixels_count = np.sum(image >= white_value)
        white_pixels_counts.append(white_pixels_count)

        # Update the mask with the current image's non-white pixel mask
        common_non_white_mask &= (image < white_value)

    # Convert white pixel counts to numpy array for statistical calculations
    white_pixels_counts = np.array(white_pixels_counts)
    average_white_pixels = np.mean(white_pixels_counts)
    std_dev_white_pixels = np.std(white_pixels_counts)

    # Calculate the average percentage of white and non-white pixels
    avg_percent_white_pixels = average_white_pixels / (image_w * image_h) * 100
    avg_percent_non_white_pixels = 100 - avg_percent_white_pixels

    # Count the number of common non-white pixels
    common_non_white_pixels_count = np.sum(common_non_white_mask)

    # Store results
    results.append({
        "class": i,
        "average_white_pixels": average_white_pixels,
        "std_dev_white_pixels": std_dev_white_pixels,
        "avg_percent_white_pixels": avg_percent_white_pixels,
        "avg_percent_non_white_pixels": avg_percent_non_white_pixels,
        "common_non_white_pixels_count": common_non_white_pixels_count,
        "percent_common_non_white_pixels": common_non_white_pixels_count / (image_w * image_h) * 100
          })
    white_pixel_stats[i] = (average_white_pixels, std_dev_white_pixels )

# Print all results at the end
for result in results:
    print("white pixels Class:", result["class"])
    print("Average white pixels:", result["average_white_pixels"])
    print("Standard deviation:", result["std_dev_white_pixels"])
    print("AVG % of white pixel:", result["avg_percent_white_pixels"])
    print("AVG % of non-white pixel:", result["avg_percent_non_white_pixels"])
    print("Number of common non-white pixels:", result["common_non_white_pixels_count"])
    print("Percentage of common non-white pixels:", result["percent_common_non_white_pixels"])
    print("\n")

classes = [f'Class {x}' for x in white_pixel_stats]
averages = [white_pixel_stats[x][0] for x in white_pixel_stats]
std_devs = [white_pixel_stats[x][1] for x in white_pixel_stats]

# Plotting
plt.figure(figsize=(10, 6))
bar_width = 0.6
bars = plt.bar(classes, averages, color='blue', width=bar_width, label='Average White Pixels') # Create bars with the averages
# Error bars indicating standard deviation

plt.errorbar(classes, averages, yerr=std_devs, fmt='o', color='red', capsize=5, label='Standard Deviation')
plt.xlabel('Classes')
plt.ylabel('Average White Pixels')
plt.title('Average and Standard Deviation of White Pixels by Class')
plt.legend()
plt.show()

"""## From the above histogram, we can clearly understand that number '1' has a unique average number of white pixels, probably because this number is generally built with one line component compared to other numbers."""

# Example of image number 55, color histogram
print(f'Example of number {y_train[55]}, color histogram \n')
plt.hist(x_train[55])

# Check TensorFlow version
print("TensorFlow version:", tf.__version__)

# Normalize pixel values to a range of 0 to 1
x_train, x_test = x_train / 255.0, x_test / 255.0

# Build a simple neural network model
def get_model_nn():
    model_nn = tf.keras.models.Sequential([
        tf.keras.layers.Flatten(input_shape=(28, 28)),  # Flatten the 28x28 images to a 1D array
        tf.keras.layers.Dense(128, activation='relu'),  # Fully connected layer with 128 units and ReLU activation
        tf.keras.layers.Dense(128, activation='relu'),  # Fully connected layer with 128 units and ReLU activation
        tf.keras.layers.Dropout(0.2),  # Dropout layer to prevent overfitting
        tf.keras.layers.Dense(10)  # Output layer with 10 units (one for each digit class)
    ])

    # Compile the model
    model_nn.compile(optimizer='adam',
                  loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
                  metrics=['accuracy'])

    return model_nn

model_nn = get_model_nn()

# Train the model
model_nn_history = model_nn.fit(x_train, y_train, epochs=15,
                          validation_data=(x_test, y_test))

# Evaluate the model on test data
from sklearn.metrics import classification_report, confusion_matrix

def model_Evaluation(model,x_test, y_test):
    model_results = model.evaluate(x_test, y_test, verbose=2)
    print("\nTest Loss:", model_results[0])
    print("\nTest accuracy:", model_results[1])

    # Additional metrics
    y_pred = model.predict(x_test).argmax(axis=1)
    report = classification_report(y_test, y_pred, output_dict=True)
    print(f'Classification report: {report}')

    conf_matrix = confusion_matrix(y_test, y_pred)
    sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title('Confusion Matrix')
    plt.show()

model_Evaluation(model=model_nn ,x_test=x_test, y_test=y_test)

"""## The overall preformance are good with Accuracy is 0.98. we can see that Class 5 has notable misclassifications as class 3. Class 9 is often confused with class 7.

"""

def show_model_loss(model_history):
    train_loss = model_history.history['loss']
    val_loss = model_history.history['val_loss']

    epochs = range(1, len(train_loss) + 1)

    # Plotting both the training loss and the validation loss
    plt.figure(figsize=(10, 5))
    plt.plot(epochs, train_loss, 'b-',marker='o',linestyle='-', label='Training Loss')
    plt.plot(epochs, val_loss, 'r-',marker='o',linestyle='-', label='Validation Loss')
    plt.title('Train & Validation Loss per Epoch')  # Title of the plot
    plt.xlabel('Epochs')  # X-axis label
    plt.ylabel('Loss')  # Y-axis label
    plt.legend()
    plt.grid(True)  # Adds a grid
    plt.show()

    # Best model recomandation
    optimal_epochs = val_loss.index(min(val_loss)) + 1
    print("\nOptimal number of epochs:", optimal_epochs)
show_model_loss(model_nn_history)

"""## Applying a 'blur' effect to the images by averaging all pixel's surroundings.
## To implement it I will use a convolution operation with a kernel size 3x3
## where his function will average the center pixel with his surroundings.

"""

## Implementing "blur" the image by averaging all pixels surroundings

from scipy.signal import correlate2d

def apply_mean_filter(image, kernel_size=3):
    """
    Applies a mean filter to an image.
    :param image: 2D array of the image (one channel).
    :param kernel_size: Size of the square kernel, default is 3x3.
    :return: Filtered image.
    """
    # Create a kernel of shape (kernel_size, kernel_size) where each element is 1/(kernel_size*kernel_size)
    kernel = np.ones((kernel_size, kernel_size)) / (kernel_size * kernel_size)

    # Apply the mean filter using 2D correlation
    # 'boundary=fill' extends the image borders by filling with zeros.
    # 'fillvalue=0' specifies the fill value to be zeros.
    filtered_image = correlate2d(image, kernel, mode='same', boundary='fill', fillvalue=0)

    return filtered_image

x_train_filtered = np.array([apply_mean_filter(img) for img in x_train])
x_test_filtered = np.array([apply_mean_filter(img) for img in x_test])

def plot_images(original, filtered, index):
    plt.figure(figsize=(6, 3))
    plt.subplot(1, 2, 1)
    plt.imshow(original[index], cmap='gray')
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(filtered[index], cmap='gray')
    plt.title('Filtered Image')
    plt.axis('off')

    plt.show()

# Example: plot the first image in the dataset
plot_images(x_train, x_train_filtered, 0)

x_train_filtered[0].shape

# Train new model with filtered data
model_nn_filter = get_model_nn()
filtered_model_history = model_nn_filter.fit(x_train_filtered, y_train, epochs=15,
                          validation_data=(x_test_filtered, y_test))

# Evaluating filtered images model
model_Evaluation(model=model_nn_filter ,x_test=x_test_filtered, y_test=y_test)

"""## We can see that the model Accuracy raised a bit to 0.98 - model is worse now with a minor change comparing to the "un-filtered image" of the previous model. Also have missclasifications problem with the numbers 9 - 4, and 5 - 3."""

# Filter model loss
show_model_loss(filtered_model_history)

"""## PCA - Principal Component Analysis, dimensionality reduction method"""

# Apply PCA dimantion reduction

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

def apply_PCA(train_to_pca, test_to_pca):

    x_train_flat = train_to_pca.reshape(train_to_pca.shape[0], -1)  # Reshape from (60000, 28, 28) to (60000, 784)
    x_test_flat = test_to_pca.reshape(test_to_pca.shape[0], -1)
    scaler = StandardScaler()
    x_train_scaled = scaler.fit_transform(x_train_flat)
    x_test_scaled = scaler.transform(x_test_flat)
    pca = PCA(n_components=0.95)  # Keeps 95% of variance
    train_pca = pca.fit_transform(x_train_scaled) # Fit on training data only
    test_pca = pca.transform(x_test_scaled) # Apply the mapping (transform) to both the training set and the test set.

    cumulative_variance = np.cumsum(pca.explained_variance_ratio_)
    plt.figure(figsize=(8, 5))
    plt.plot(cumulative_variance)
    plt.xlabel('Number of Components')
    plt.ylabel('Cumulative Explained Variance')
    plt.title('Cumulative Explained Variance by PCA Components')
    plt.grid(True)
    plt.show()

    # print("\nExplained variance ratio: \n", pca.explained_variance_ratio_, '\n')
    print("Total variance explained by all chosen components:", sum(pca.explained_variance_ratio_), '\n')


    return train_pca, test_pca

x_train_pca, x_test_pca = apply_PCA(train_to_pca = x_train, test_to_pca = x_test )
#x_train_pca = np.array(x_train_pca)
#x_test_pca = np.array(x_test_pca)

# Checking train test shape
print("Shape of PCA-transformed training data:", x_train_pca.shape)
print("Shape of PCA-transformed testing data:", x_test_pca.shape)

# Train new models with PCA and modify model Architecture
model_nn_pca = tf.keras.models.Sequential([
        tf.keras.layers.Flatten(input_shape=(x_train_pca.shape[1],)),  # Flatten to PCA dimantion
        tf.keras.layers.Dense(128, activation='relu'),  # Fully connected layer with 128 units and ReLU activation
        tf.keras.layers.Dense(128, activation='relu'),  # Fully connected layer with 128 units and ReLU activation
        tf.keras.layers.Dropout(0.2),  # Dropout layer to prevent overfitting
        tf.keras.layers.Dense(10)  # Output layer with 10 units (one for each digit class)
        ])

# Compile the model
model_nn_pca.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

model_nn_pca_history = model_nn_pca.fit(x_train_pca, y_train, epochs=15,
                          validation_data=(x_test_pca, y_test))
model_Evaluation(model=model_nn_pca ,x_test=x_test_pca, y_test=y_test)
show_model_loss(model_nn_pca_history)

"""### The model accuracy has dropped to 0.97 with PCA features on the data. Also, the phenomena with numbers 4 and 9 still occur, but this misdetection is even better. PCA transforms the data into 1 dimension with 331 features into the sequential network. We can see that PCA helps the model with noise reduction, improved training stability, and faster convergence, as it is easier to understand the optimal epoch from the loss function graph."""

# Convulotion - dimension reduction by replacing each non-overlapping 3x3 pixel block with its average value
from scipy.signal import correlate2d

def apply_convolution(image, kernel, add_padding=False):
    """
    Apply a 2D convolution to an image using a specified kernel, with an option to add padding.

    Args:
    image (numpy.ndarray): The input image array.
    kernel (numpy.ndarray): The convolution kernel.
    add_padding (bool): If True, adds padding to the image to preserve the original size.

    Returns:
    numpy.ndarray: The convolved image.
    """
    if add_padding: # Calculate the required padding size for each dimension
        pad_height = kernel.shape[0] // 2
        pad_width = kernel.shape[1] // 2

        image_padded = np.pad(image, ((pad_height, pad_height), (pad_width, pad_width)), mode='constant')
    else:
        image_padded = image

    result = correlate2d(image_padded, kernel, mode='same', boundary='fill', fillvalue=0)

    if add_padding:
        # Remove the padding to restore the original image size
        result = result[pad_height:-pad_height, pad_width:-pad_width]

    return result

# set Kernel
kernel = np.array([[1, 1, 1],
                   [1, 1, 1],
                   [1, 1, 1]]) / 9

# Apply convolution with padding
x_train_conv = [apply_convolution(img, kernel, add_padding=True) for img in x_train]
x_train_conv = np.array(x_train_conv)
x_test_conv = [apply_convolution(img, kernel, add_padding=True) for img in x_test]
x_test_conv = np.array(x_test_conv)


def plot_images(original, conv_with_padding):
    plt.figure(figsize=(12, 4))
    titles = ['Original Image', 'Convolution with Padding']
    images = [original, conv_with_padding]
    for i, img in enumerate(images):
        plt.subplot(1, 3, i + 1)
        plt.imshow(img, cmap='gray')
        plt.title(titles[i])
        plt.axis('off')
    plt.show()

# Plot the images
plot_images(x_train[55], x_train_conv[55])
print("Conv shape: ",x_test_conv[55].shape)

# Train new models with Convolutions
model_nn_conv = get_model_nn()
model_nn_conv_history = model_nn_conv.fit(x_train_conv, y_train, epochs=15,
                          validation_data=(x_test_conv, y_test))
model_Evaluation(model=model_nn_conv ,x_test=x_test_conv, y_test=y_test)
show_model_loss(model_nn_conv_history)

"""### Now we got better results with a higher accuracy of 0.982. The problem with the '4' and '9' numbers is better now; it looks like predicting the number '4' is solved and distinguished. However, the phenomenon in the other direction, where predicting '9' is still confused with the number '4', persists with its misclassification. Also, we can see that the optimal epoch is number 9, as it has the least error from the loss function, but it is hard to distinguish between its nearby epochs as the loss values look pretty stable."""

# New Data - Undersampled classes 3, and 5

x_train_reshaped = x_train.reshape(x_train.shape[0], -1)
data = pd.DataFrame(x_train_reshaped)
data['label'] = y_train

undersample_ratio = 0.5 #undersampling ratio

class_3_indices = data[data['label'] == 3].index
class_5_indices = data[data['label'] == 5].index

# Randomly select a subset
class_3_indices_to_keep = np.random.choice(class_3_indices, int(len(class_3_indices) * undersample_ratio), replace=False)
class_5_indices_to_keep = np.random.choice(class_5_indices, int(len(class_5_indices) * undersample_ratio), replace=False)
other_indices = data[~data['label'].isin([3, 5])].index

indices_to_keep = np.concatenate([class_3_indices_to_keep, class_5_indices_to_keep, other_indices])
new_data = data.loc[indices_to_keep]
undersample_x_train = new_data.drop(columns=['label']).values
undersample_y_train = new_data['label'].values
undersample_x_train = undersample_x_train.reshape(undersample_x_train.shape[0], 28, 28)

print(undersample_x_train.shape)
print(undersample_y_train.shape)

# plot the 50% undersampling
def plot_hist_num_of_classes(y_data_to_plot, operation):
    class_counts = np.bincount(y_data_to_plot)
    plt.figure(figsize=(10, 6))
    plt.bar(range(len(class_counts)), class_counts, color='blue', alpha=0.7)
    plt.xlabel('Class')
    plt.ylabel('Number of Images')
    plt.title('Number of Images per Class after '+ operation)
    plt.xticks(range(len(class_counts)))
    plt.show()

plot_hist_num_of_classes(y_data_to_plot = undersample_y_train, operation='Undersampling')

"""## This plot represent the reduction of classes '3' and '5' by the undersampling operation"""

# Train new models with undersampled classes 3, and 5
model_nn_undersample = get_model_nn()
model_nn_undersample_history = model_nn_undersample.fit(undersample_x_train, undersample_y_train, epochs=15,
                          validation_data=(x_test, y_test))
model_Evaluation(model=model_nn_undersample ,x_test=x_test, y_test=y_test)
show_model_loss(model_nn_undersample_history)

"""### Explanation of Undersampling - Deals with Less Data: As expected, the accuracy decreased to 0.97. When we have less data to train on, the model performance is affected. The accuracy is still high, so we can conclude that this amount of data is large enough to train the model. Moreover, compared to the previous models, the value of precision for class '5' decreased from 0.9873 to 0.9772 by undersampling the class. This operation is only for exploration and understanding the importance of data scale."""

# Augmentaion for classes '4' and '9'

import cv2
import random
from skimage.util import random_noise
from skimage import filters

def augment_image(image):
    # Rotation
    angle = random.randint(-15, 15)
    M = cv2.getRotationMatrix2D((image.shape[1] / 2, image.shape[0] / 2), angle, 1)
    rotated = cv2.warpAffine(image, M, (image.shape[1], image.shape[0]))

    # Flipping
    flipped = cv2.flip(image, 1)  # Horizontal flip

    # Blurring
    blurred = cv2.GaussianBlur(image, (5, 5), 0)

    return [rotated, flipped, blurred]

# Original x_train and y_train
x_train_reshaped = x_train.reshape(x_train.shape[0], 28, 28)
#y_train = y_train

# Lists to store augmented data
x_train_augmented = []
y_train_augmented = []

# Augment only classes 4 and 9
for image, label in zip(x_train_reshaped, y_train):
    x_train_augmented.append(image)
    y_train_augmented.append(label)
    if label == 4 or label == 9:
        augmented_images = augment_image(image)
        for aug_image in augmented_images:
            x_train_augmented.append(aug_image)
            y_train_augmented.append(label)

# Convert lists to arrays
x_train_augmented = np.array(x_train_augmented)
y_train_augmented = np.array(y_train_augmented)

# Reshape x_train_augmented to the original shape (num_samples, 28, 28)
x_train_augmented = x_train_augmented.reshape(x_train_augmented.shape[0], 28, 28)

print(x_train_augmented.shape)
print(y_train_augmented.shape)

plot_hist_num_of_classes(y_data_to_plot = y_train_augmented , operation='Augmentaion')

# Train new models with Augmentaion classes 4, and 9
model_nn_augment = get_model_nn()
model_nn_augment_history = model_nn_augment.fit(x_train_augmented, y_train_augmented, epochs=15,
                          validation_data=(x_test, y_test))
model_Evaluation(model=model_nn_augment ,x_test=x_test, y_test=y_test)
show_model_loss(model_nn_augment_history)

# Comparing the training sets size
unsamp_len = len(undersample_y_train)
aug_len = len(y_train_augmented)
print(f"Unsamples data set have {unsamp_len} images")
print(f"Augmentation data set have {aug_len} images")
print(f"Which is {round((aug_len-unsamp_len)/unsamp_len*100,2)}% more for images in Augmented data set")

"""### We get around the same accuracy for the augmentation and the undersampling datasets and models. Augmentation should increase the accuracy of the model since there is more data to train on, but this also increases the running time. Undersampling, on the other hand, should have decreased the accuracy for the opposite reason and decreased the running time. Also, when I add augmentation as extra data for the training set, I manually create an unbalanced dataset for classes '4' and '9', which also creates a problem as the model is biased towards those classes.

### ***THANK YOU !***
"""